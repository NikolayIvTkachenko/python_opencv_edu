# ArUco маркеры представляют собой специальные двумерные бинарные маркеры, используемые
# в области компьютерного зрения для различных задач, таких как:
#
# Распознавание и отслеживание объектов: Маркеры позволяют идентифицировать объекты и отслеживать их
# положение и ориентацию в пространстве.
# Калибровка камер: Используются для точной настройки параметров камеры, что особенно важно в стереозрении и
# 3D реконструкции.
# Дополненная реальность (AR): Служат привязками для наложения виртуальных объектов на реальное изображение.
# Робототехника: Помогают в навигации и ориентировании роботов в пространстве.
#
# Выше представлены примеры ArUco маркеров разных размеров.
#
# Размеры ArUco маркеров:
#
# Размер ArUco маркера определяется количеством ячеек в его внутренней бинарной матрице, которая кодирует уникальный
# идентификатор. Наиболее распространенные размеры маркеров:
#
# 4x4 : Маркеры с матрицей 4x4 содержат 16 бит информации. Они просты в обнаружении и требуют меньше вычислительных
# ресурсов, но количество уникальных маркеров ограничено (обычно до 250). Подходят для приложений, где не требуется большое
# количество различных маркеров.
#
# 5x5 : Маркеры 5x5 содержат 25 бит информации. Это увеличивает количество возможных уникальных идентификаторов и повышает
# устойчивость к шумам и искажениям по сравнению с 4x4 маркерами.
#
# 6x6 : С матрицей 6x6, маркеры имеют 36 бит информации. Это значительно увеличивает пространство уникальных идентификаторов
# и обеспечивает лучшую устойчивость к ошибкам считывания.
#
# 7x7 : Маркеры 7x7 с 49 битами предоставляют самое большое количество уникальных идентификаторов и наивысшую устойчивость
# к шумам и искажениям, но они более сложны в обнаружении и требуют больше вычислительных ресурсов.
#
# Выбор размера маркера зависит от следующих факторов:
#
# Количество уникальных идентификаторов: Если в приложении требуется большое количество различных маркеров, предпочтительнее
# использовать маркеры с большей матрицей (например, 6x6 или 7x7).
#
# Условия съемки: В условиях плохого освещения, высоких шумов или больших расстояний до камеры более крупные маркеры
# (с большим количеством бит) обеспечат более надежное обнаружение и декодирование.
#
# Вычислительные ресурсы: Маркеры с меньшей матрицей (4x4, 5x5) требуют меньше ресурсов для обработки и быстрее обнаруживаются,
# что важно для систем реального времени или устройств с ограниченными ресурсами.
#
# Размер маркера в физическом пространстве: При печати маркеров важно учитывать физические размеры. Маркеры с большей
# матрицей могут потребовать более крупный физический размер, чтобы обеспечить достаточное разрешение для камеры.
#
# Важно учитывать баланс между устойчивостью и производительностью при выборе размера маркера для конкретного приложения.
#
# Преимущества ArUco маркеров:
#
# Простота генерации и обнаружения: Благодаря бинарной природе, их легко создавать и распознавать с помощью алгоритмов
# компьютерного зрения.
# Уникальные идентификаторы: Каждый маркер имеет свой уникальный ID, что позволяет различать их между собой.
# Устойчивость к шуму и искажениям: Алгоритмы обнаружения маркеров разработаны так, чтобы быть устойчивыми к различным
# условиям съемки.
# Широкое применение: Поддерживаются многими библиотеками, включая OpenCV, что облегчает их интеграцию в проекты.
# Процесс обнаружения ArUco маркеров включает несколько основных этапов:
#
# Предобработка изображения: Улучшение качества изображения для повышения точности обнаружения (например, фильтрация
# шума, коррекция освещенности).
# Поиск контуров: Алгоритм ищет возможные контуры, которые могут соответствовать маркерам.
# Идентификация потенциальных маркеров: Выделение квадратных областей, которые могут быть маркерами.
# Бинаризация и декодирование: Извлечение внутреннего бинарного кода из предполагаемых маркеров.
# Проверка и коррекция ошибок: Использование методов коррекции ошибок для подтверждения подлинности маркера и получения
# его идентификатора.
# Вывод результатов: Предоставление информации о найденных маркерах, их углах, идентификаторах и т.д.
# Происхождение названия "ArUco":
# "Ar" — сокращение от Augmented Reality (дополненная реальность).
# "UCo" — аббревиатура от University of Cordoba (Университет Кордовы) в Испании, где была разработана эта библиотека.

#------
# Общая структура маркера
# ArUco маркер представляет собой квадратное изображение, состоящее из черных и белых клеток. Он включает в себя
# три основных компонента:

# Границы: Белая и черная рамки вокруг маркера, обычно толщиной в один или несколько бит.
# Они помогает алгоритму обнаружения отделить маркер от фона и определить его ориентацию.
#
# Бинарная матрица: Внутренняя область маркера, состоящая из черных и белых клеток, которые кодируют
# бинарный код маркера. Размер матрицы определяется количеством ячеек по горизонтали и вертикали (например, 4x4, 5x5, 6x6).
#
# Уникальный идентификатор (ID): Бинарный код, закодированный в матрице, который однозначно идентифицирует
# маркер в рамках выбранного словаря. Каждая ячейка матрицы представляет собой 1 бит информации: черная клетка — бит "1",
# белая клетка — бит "0" (или наоборот, в зависимости от реализации). Все ячейки вместе образуют последовательность битов,
# которая интерпретируется как число в двоичной системе счисления.
# Бинарный код из матрицы преобразуется в десятичное число, которое и является идентификатором маркера.
# Порядок чтения битов обычно начинается с верхнего левого угла и идет по строкам слева направо и сверху вниз.
#
# Кодирование маркеров с использованием словарей
# Словарь в контексте ArUco маркеров представляет собой набор предопределенных бинарных матриц (паттернов),
# каждая из которых связана с уникальным идентификатором (ID).
# Словари обеспечивают:
# Уникальность маркеров: Каждый маркер в словаре уникален и не совпадает с другими маркерами или их поворотами.
# Устойчивость к поворотам: Маркеры в словаре спроектированы таким образом, чтобы идентификатор оставался неизменным
# независимо от поворота маркера.
# Почему биты не кодируются напрямую
# Если бы мы напрямую преобразовывали ID в бинарный код и заполняли им матрицу маркера, это могло бы привести к тому,
# что повороты или зеркальные отражения маркера давали бы другой ID при декодировании. Маркер, повернутый на определенный угол, может иметь совершенно другой бинарный код при чтении сверху вниз и слева направо.
#
# Процесс создания словаря
# Генерация всех возможных комбинаций бинарных матриц для заданного размера (например, для 4x4 матрицы это
# 2
# 16
# 2
# 16
#   возможных комбинаций).
# Проверка каждой матрицы на уникальность с учетом всех ее поворотов и отражений:
# Генерируются все повороты (0°, 90°, 180°, 270°) и зеркальные отражения матрицы.
# Если какой-либо из этих вариантов совпадает с другой матрицей, такая матрица исключается.
# Выбор матриц с достаточным расстоянием Хэмминга до других матриц (об этом подробнее далее).
# Формирование словаря из оставшихся уникальных матриц и присвоение им идентификаторов.
# Расстояние Хэмминга: что это такое и зачем его оценивать
# Расстояние Хэмминга между двумя бинарными кодами — это количество позиций, в которых соответствующие биты различаются.
#
# Пример:
# Код A: 10110011
# Код B: 10011001
# Расстояние Хэмминга между A и B равно 3 (отличаются биты на позициях 2, 4 и 6).
# Ограничение минимального расстояния Хэмминга между маркерами в словаре гарантирует, что маркеры достаточно отличаются
# друг от друга, что снижает вероятность ошибки при распознавании.
#
# Увеличение минимального расстояния Хэмминга между маркерами уменьшает общее количество уникальных маркеров в словаре.
#
# Необходимо найти баланс между требуемым количеством маркеров и необходимой устойчивостью к ошибкам.

# Использование модуля aruco из OpenCV для обработки изображений с маркерами
# Модуль cv2.aruco: предоставляет инструменты для работы с ArUco маркерами, включая их генерацию и обнаружение. Важно отметить, что модуль доступен только при установке расширенного пакета opencv-contrib-python. Мы это обсуждали в одном из первых уроков: https://stepik.org/lesson/652507/step/1?unit=649232
#
# Расположенные в следующих шагах примеры кода актуальны для версии OpenCV >= 4.7.0
# Узнать вашу версию:
#
# import cv2
# print(cv2.__version__)
# Словари маркеров
# Словарь маркеров содержит набор уникальных маркеров, которые можно использовать в вашем коде. OpenCV предоставляет несколько предопределенных словарей:
#
# cv2.aruco.DICT_4X4_50
# cv2.aruco.DICT_4X4_100
# cv2.aruco.DICT_4X4_250
# cv2.aruco.DICT_4X4_1000
# cv2.aruco.DICT_5X5_50
# cv2.aruco.DICT_5X5_100
# cv2.aruco.DICT_5X5_250
# cv2.aruco.DICT_5X5_1000
# cv2.aruco.DICT_6X6_50
# cv2.aruco.DICT_6X6_100
# cv2.aruco.DICT_6X6_250
# cv2.aruco.DICT_6X6_1000
# cv2.aruco.DICT_7X7_50
# cv2.aruco.DICT_7X7_100
# cv2.aruco.DICT_7X7_250
# cv2.aruco.DICT_7X7_1000
# Для каждой задачи выбирается свой словарь, исходя из типа используемых маркеров. Также для эффективной работы важно выбирать словарь с наименьшим необходимым числом маркеров.
# Пример подключения словаря для версии OpenCV >= 4.7.0:

# import cv2
# aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_100)
# Пример подключения словаря для версии OpenCV < 4.7.0:
#
# import cv2
# aruco_dict = cv2.aruco.Dictionary_get(cv2.aruco.DICT_4X4_100)
# В данном примере мы используем словарь DICT_4X4_100, который содержит 100 маркеров размером 4x4 бит.
#
# Обнаружение маркеров на изображении

# Для обнаружения маркеров на изображении используйте следующий код:
import cv2
import numpy as np

# Читаем изображение
image = cv2.imread('aruco_marker_10.png')

# Подключаем необходимый словарь
aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_5X5_100) #cv2.aruco.DICT_6X6_100 #cv2.aruco.DICT_4X4_100

# Преобразование в градации серого
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Создание детектора маркеров
detectorParams = cv2.aruco.DetectorParameters()
detector = cv2.aruco.ArucoDetector(aruco_dict , detectorParams)

# Обнаружение маркеров
corners, ids, rejectedImgPoints = detector.detectMarkers(image)


# Отображение результатов
if ids is not None:
    print("Углы маркеров", corners)
    print("ID маркеров:", ids)
    cv2.aruco.drawDetectedMarkers(image, corners, ids)
    cv2.imshow('Detected Markers', image)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
else:
    print("Маркер не найден.")


# Пример поиска маркеров для версии OpenCV < 4.7.0:
#
# detectorParams = cv2.aruco.DetectorParameters_create()
# corners, ids, rejectedImgPoints = cv2.aruco.detectMarkers(image, dictionary, parameters=detectorParams)
#
# Формат выходных данных
# corners: список координат углов обнаруженных маркеров. Каждый элемент списка соответствует одному маркеру и содержит массив из четырех точек (углов маркера) в порядке следования по часовой стрелке начиная с левого верхнего угла.
#
# (array([[[ 167.,  167.],
#         [1166.,  167.],
#         [1166., 1166.],
#         [ 167., 1166.]]], dtype=float32),)
# Обратите внимание! Встроенный метод cv2.aruco.drawDetectedMarkers(image, corners, ids)
# рисует точки но не подписывает их. Для удобства и наглядности, добавьте в код цикл:
#
# # Проходим по каждому обнаруженному маркеру
# for i in range(len(ids)):
#     # Получаем уголки текущего маркера
#     corner = corners[i][0]
#     # Проходим по каждому углу маркера
#     for j in range(4):
#         # Координаты угла
#         x, y = int(corner[j][0]), int(corner[j][1])
#         # Подпись угла
#         label = f"{j}: ({x}, {y})"
#         # Наносим подпись на изображение
#         cv2.putText(image, label, (x, y - 10), cv2.FONT_HERSHEY_COMPLEX, 0.5, (100, 100, 0), 2)
#         # Рисуем маленький круг на месте угла для наглядности
#         cv2.circle(image, (x, y), 3, (255, 0, 255), -1)
# ids: массив идентификаторов обнаруженных маркеров. Соответствует списку corners. Т.е. для расположенного
# с индексом 0 ID маркера координаты также будут с списке corners с индексом 0.
#
# marker_id = ids[0][0]
# rejectedImgPoints: список контуров, которые были распознаны как потенциальные маркеры, но не прошли проверку.

#
# Простое обнаружение ID ArUco-маркера
# В программу передается изображение маркера (только один маркер) размером 5х5.
# Гарантируется, что изображение является маркером.
# Похожие файлы с маркерами 5х5 можно скачать тут: Ссылка
#
# Ваша задача: вывести ID маркера
# import cv2
# import numpy as np
# import base64
#
# def read_image(input_text):
#     img = cv2.imdecode(np.frombuffer(base64.b64decode(input_text), dtype=np.uint8), cv2.IMREAD_COLOR)
#     return img
#
# image = read_image(input())
# aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_5X5_100)
#
# # Преобразование в градации серого
# gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
#
# # Создание детектора маркеров
# detectorParams = cv2.aruco.DetectorParameters()
# detector = cv2.aruco.ArucoDetector(aruco_dict , detectorParams)
#
# # Обнаружение маркеров
# corners, ids, rejectedImgPoints = detector.detectMarkers(image)
# print(ids[0][0])

#===========================================================
# Ключевые точки маркеров
# В одном из шагов предыдущего урока мы уже говорили о ключевых точках ArUco-маркеров.
# После определения они попадают в переменную corners в виде массива:
#
# corners, ids, rejectedImgPoints = detector.detectMarkers(image)

# Рассмотрим ситуацию, когда маркер в кадре гарантированно один. В переменной corners будут примерно такие данные:
#
# (array([[[ 167.,  167.],
#         [1166.,  167.],
#         [1166., 1166.],
#         [ 167., 1166.]]], dtype=float32),)
# Обратите внимание на то, что массив многоуровневый, т.к. его размерность позволяет хранить точки многих маркеров.
#
# Важно! Точки маркера расположены в строгом порядке (начиная с левого верхнего угла по часовой стрелке):
#
# Точка 0 - верхний левый угол
# Точка 1 - верхний правый угол
# Точка 2 - нижний правый угол
# Точка 3 - нижний левый угол
# Порядок точек сохранится даже в случае, когда маркер в кадре будет перевернут!


#==================================
# Произвольное определение угла поворота маркера
# В предыдущем решении вы определяли угол поворота маркера, сравнивая координаты его углов и используя оператор
# if (предположительно :-) ) для дискретных значений угла (0°, 90°, 180°, 270°). Этот метод работает только для
# маркеров, повернутых на кратные 90° углы. Однако, в реальных приложениях маркер может быть повернут на произвольный
# угол. Поэтому возникает необходимость разработать метод, который позволит определить угол поворота маркера с точностью
# до любого значения.
#
# Далее мы подробно рассмотрим теоретические основы, позволяющие перейти от дискретного определения угла поворота
# к произвольному.
#
# Чтобы определить произвольный угол поворота маркера, необходимо использовать методы аналитической
# геометрии и тригонометрии (но не все так сложно, как звучит).
# Основная идея заключается в следующем:
# Векторное представление: Рассматриваем сторону маркера как вектор в двумерном пространстве.
# Вычисление угла между вектором и осью координат: Используем арктангенс (atan2) для определения угла между
# вектором и осью X.
# Нормализация угла: Приводим вычисленный угол к диапазону от 0° до 360°.
# Учет ориентации: Используем направление сторон маркера для точного определения угла.
# Шаги по определению произвольного угла поворота
# Шаг 1: Извлечение координат углов маркера
#
# После обнаружения маркера с помощью функции detectMarkers, мы получаем массив координат его углов:
#
# marker_corners = corners[0][0]
#
# marker_corners представляет собой массив из четырех точек (углов маркера):
#
# [
#     [x0, y0],  # Верхний левый угол
#     [x1, y1],  # Верхний правый угол
#     [x2, y2],  # Нижний правый угол
#     [x3, y3]   # Нижний левый угол
# ]
# Шаг 2: Вычисление вектора стороны маркера
#
# Выбираем одну из сторон маркера для вычисления вектора. Например, сторону между первым и вторым углами:
#
# vector = marker_corners[1] - marker_corners[0]
#
# Шаг 3: Вычисление угла вектора относительно оси X
#
# Используем функцию atan2 из модуля math, которая возвращает угол между осью X и вектором в радианах:
#
# import math
# angle_rad = math.atan2(vector[1], vector[0])
# Преобразуем угол из радиан в градусы:
#
# angle_deg = math.degrees(angle_rad)
#
# Шаг 4: Нормализация угла
#
# Полученный угол может быть отрицательным или превышать 360°. Приводим его к диапазону от 0° до 360°:
#
# angle_normalized = (angle_deg + 360) % 360
#
# Шаг 5: Определение окончательного угла поворота
#
# Теперь мы имеем точный угол поворота маркера относительно оси X. При необходимости можем округлить его до нужной
# точности или оставить как есть.
#-----------------------------------------------
# Детектирование нескольких маркеров
# В реальных задачах компьютерного зрения часто возникает необходимость работать с
# несколькими ArUco-маркерами , присутствующими на одном изображении. Например, это
# может быть полезно для определения положения и ориентации объектов в пространстве,
# калибровки камер или отслеживания движения.
#
# Когда на изображении присутствует несколько маркеров ArUco, функция detectMarkers из
# библиотеки OpenCV способна обнаружить все маркеры, соответствующие заданному словарю. Эта функция возвращает:
#
# corners: список координат углов для каждого обнаруженного маркера.
# ids: список идентификаторов (ID) для каждого обнаруженного маркера.
# rejectedImgPoints: список точек, которые могли быть маркерами, но не прошли проверку.
# После обнаружения маркеров необходимо:
#
# Проверить, что маркеры найдены:
#
# if ids is not None and len(ids) > 0:
#     # Обработка маркеров
# else:
#     print("Маркеры не обнаружены")
# Перебирать по каждому маркеру:
# for i in range(len(ids)):
#     marker_id = ids[i][0]
#     marker_corners = corners[i][0]
#     # Дальнейшая обработка каждого маркера
# Здесь ids[i][0] — идентификатор текущего маркера, а corners[i][0] — массив координат его углов. Т.е. ID и соответствующие им координаты углов будут расположены под одинаковыми индексами
#
# Вычисление центра маркера
# Положение маркера можно определить по координатам его углов. Часто используется центр маркера, который можно вычислить как среднее значение координат его углов.
#
# Пример вычисления центра маркера:
#
# # Координаты углов маркера
# marker_corners = corners[i][0]  # Массив из 4 точек
#
# # Вычисление центра маркера
# center_x = np.mean(marker_corners[:, 0])
# center_y = np.mean(marker_corners[:, 1])
# center = (center_x, center_y)
#==================
# Определяем
# координаты
# точек
# определенного
# маркера
# В
# задачах, стоящих
# перед
# программистами
# систем
# компьютерного
# зрения
# возникает
# необходимость
# не
# только
# обнаружить
# все
# маркеры
# на
# изображении, но
# и
# найти
# конкретный
# маркер
# с
# известным
# идентификатором(ID)
# и
# извлечь
# его
# характеристики, такие
# как
# координаты
# углов(ключевых
# точек).
#
# В
# следующей
# задаче
# вам
# требуется
# определить
# координаты
# углов
# маркера
# с
# заданным
# ID.
#
# Шаг
# 1: Детектирование
# всех
# маркеров
# на
# изображении
# Первым
# шагом
# является
# обнаружение
# всех
# ArUco - маркеров
# на
# изображении.
#
# Код
# для
# детектирования
# маркеров:
#
# import cv2
# import numpy as np
#
# # Инициализация словаря маркеров
# marker_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_50)
#
# # Создание параметров детектирования
# detector_params = cv2.aruco.DetectorParameters()
#
# # Инициализация детектора ArUco
# detector = cv2.aruco.ArucoDetector(marker_dict, detector_params)
#
# # Детектирование маркеров на изображении
# corners, ids, rejectedImgPoints = detector.detectMarkers(image)
# corners: список
# координат
# углов
# каждого
# обнаруженного
# маркера.
# ids: массив
# идентификаторов(ID)
# обнаруженных
# маркеров.
# rejectedImgPoints: дополнительные
# выходные
# данные, которые
# мы
# не
# используем.
# Шаг
# 2: Проверка
# наличия
# маркеров
# на
# изображении
# После
# попытки
# детектирования
# маркеров
# необходимо
# проверить, были
# ли
# они
# обнаружены.
#
# Код
# для
# проверки:
#
# if ids is None or len(ids) == 0:
#     print("Маркеры не обнаружены.")
# else:
# # Продолжаем обработку
# Если
# ids
# равно
# None
# или
# является
# пустым, значит, маркеры
# не
# были
# обнаружены
# на
# изображении.
#
# Шаг
# 3: Поиск
# маркера
# с
# заданным
# ID
# среди
# обнаруженных
# маркеров
# Если
# маркеры
# обнаружены, нужно
# проверить, есть
# ли
# среди
# них
# маркер
# с
# нашим
# заданным
# ID.
#
# Когда
# мы
# используем
# функцию
# detectMarkers
# из
# модуля
# cv2.aruco, она
# возвращает
# массив
# ids, который
# содержит
# идентификаторы
# обнаруженных
# маркеров.
#
# Однако
# важно
# отметить, что
# структура
# массива
# ids
# может
# быть
# не
# одномерной, а
# двумерной.Давайте
# посмотрим, как
# выглядит
# ids
# после
# детектирования.
#
# Пример:
#
# Предположим, что
# мы
# обнаружили
# три
# маркера
# с
# идентификаторами
# 5, 10
# и
# 15.
# Тогда
# массив
# ids
# может
# выглядеть
# так:
#
# ids = array([[5],
#              [10],
#              [15]], dtype=int32)
# Это
# двумерный
# массив, где
# каждая
# строка
# содержит
# один
# элемент — идентификатор
# маркера.То
# есть
# ids
# имеет
# размерность(N, 1), где
# N — количество
# обнаруженных
# маркеров.
#
# Почему
# нужно
# преобразовать
# ids
# в
# одномерный
# массив
# Для
# удобства
# обработки
# и
# поиска
# маркеров
# по
# их
# идентификаторам
# нам
# удобнее
# работать
# с
# одномерным
# массивом
# или
# списком, где
# каждый
# элемент — это
# идентификатор
# маркера.
#
# Проблема
# с
# двумерным
# массивом:
#
# Когда
# ids
# является
# двумерным
# массивом, прямое
# сравнение
# с
# числом
# может
# не
# работать
# так, как
# ожидается.
# Например, если
# мы
# попытаемся
# проверить, содержится
# ли
# заданный
# marker_id
# в
# ids
# с
# помощью
# if marker_id in ids: ,
# то
# это
# может
# не
# сработать, потому
# что
# ids
# содержит
# вложенные
# массивы, а
# не
# непосредственные
# значении, т.к.использовании
# if marker_id in ids: сравнение
# происходит
# между
# числом
# и
# массивом, что
# приводит
# к
# некорректным
# результатам.
# Преобразование
# в
# одномерный
# массив:
#
# Преобразовав
# ids
# в
# одномерный
# массив, мы
# получаем
# простой
# список
# идентификаторов, с
# которым
# удобно
# работать.
# Это
# позволяет
# нам
# использовать
# стандартные
# операции, такие
# как
# проверка
# на
# вхождение( in), поиск
# индекса
# и
# т.д.
# 3.
# Как
# работает
# метод
# flatten()
# Метод
# flatten()
# из
# библиотеки
# NumPy
# преобразует
# многомерный
# массив
# в
# одномерный, то
# есть «сплющивает» его.
#
# import numpy as np
#
# # Изначальный двумерный массив
# ids = np.array([[5],
#                 [10],
#                 [15]], dtype=int32)
#
# print("До flatten:")
# print(ids)
# print("Форма массива:", ids.shape)
#
# # Применяем flatten()
# ids_flat = ids.flatten()
#
# print("\nПосле flatten:")
# print(ids_flat)
# print("Форма массива:", ids_flat.shape)
# Вывод:
#
# До
# flatten:
# [[5]
#  [10]
#  [15]]
# Форма
# массива: (3, 1)
#
# После
# flatten:
# [5 10 15]
# Форма
# массива: (3,)
#
# Пояснение:
#
# До
# flatten(): ids — это
# двумерный
# массив
# с
# формой(3, 1), то
# есть
# 3
# строки
# и
# 1
# столбец.
# После
# flatten(): ids_flat — это
# одномерный
# массив
# с
# формой(3, ), содержащий
# элементы[5, 10, 15].
# 4.
# Применение
# в
# контексте
# поиска
# маркера
# с
# заданным
# ID
# Теперь, когда
# ids
# является
# одномерным
# массивом, мы
# можем
# легко
# проверить, содержится
# ли
# заданный
# marker_id
# в
# массиве
# ids, и
# найти
# его
# индекс.
#
# Код
# без
# flatten():
#
# marker_id = 10
#
# if marker_id in ids:
#     print("Маркер найден")
# else:
#     print("Маркер не найден")
# Однако
# это
# может
# не
# сработать, потому
# что
# ids — это
# двумерный
# массив, и
# сравнение
# происходит
# с
# вложенными
# массивами, а
# не
# с
# числами.
#
# Код
# с
# flatten():
#
# ids = ids.flatten()
#
# if marker_id in ids:
#     print("Маркер найден")
# else:
#     print("Маркер не найден")
# Теперь
# сравнение
# работает
# корректно, потому
# что
# ids — одномерный
# массив
# чисел.
#
# Наш
# план
# по
# поиску
# выглядит
# так:
# Преобразовать
# массив
# ids
# в
# одномерный
# для
# удобства
# обработки.
# Проверить, присутствует
# ли
# наш
# marker_id
# в
# массиве
# ids.
# Если
# да, получить
# индекс
# этого
# маркера
# для
# доступа
# к
# его
# углам.
# Код:
#
# # Преобразуем ids в одномерный массив
# ids = ids.flatten()
#
# # Проверяем, есть ли заданный ID среди обнаруженных
# if marker_id in ids:
#     # Находим индекс маркера с заданным ID
#     index = np.where(ids == marker_id)[0][0]
#     # Продолжаем обработку
# else:
#     print("Маркеры не обнаружены.")
# ids.flatten(): преобразует
# массив
# ids
# в
# одномерный
# массив.
# np.where(ids == marker_id): возвращает
# индексы
# элементов, равных
# marker_id.
# [0][0]: извлекаем
# первый
# индекс
# из
# результата
# np.where.
# Дополнительные[0][0]
# нужны, чтобы
# из
# структуры, которую
# возвращает
# np.where
# извлечь
# индекс
# элемента:
#
# # Предположим, ids = [5, 10, 15]
# marker_id = 10
#
# # Находим индексы элементов, равных marker_id
# indices = np.where(ids == marker_id)
#
# print("Индексы маркера с ID", marker_id, ":", indices)
# Вывод:
#
# Индексы
# маркера
# с
# ID
# 10: (array([1], dtype=int64),)
# np.where(ids == marker_id)
# возвращает
# кортеж, где
# первый
# элемент — массив
# индексов
# элементов, удовлетворяющих
# условию
# ids == marker_id.
# В
# данном
# случае, индекс
# маркера
# с
# ID
# 10
# равен
# 1.
# Шаг
# 4: Извлечение
# координат
# углов
# маркера
# с
# заданным
# ID
# Зная
# индекс
# маркера
# с
# нужным
# ID, можем
# получить
# его
# координаты
# углов
# из
# массива
# corners.
#
# Код:
#
# # Получаем координаты углов маркера с заданным ID
# marker_corners = corners[index][0]  # Размерность (4, 2)
# corners[index][0]: выбираем
# первый(и
# единственный) элемент
# внутреннего
# массива
# углов
# для
# маркера
# с
# заданным
# индексом.
#
# Структура
# marker_corners:
#
# [
#     [x0, y0],  # Точка 0: верхний левый угол
#     [x1, y1],  # Точка 1: верхний правый угол
#     [x2, y2],  # Точка 2: нижний правый угол
#     [x3, y3]  # Точка 3: нижний левый угол
# ]