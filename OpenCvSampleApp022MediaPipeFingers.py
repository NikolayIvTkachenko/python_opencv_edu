# Функция cv2.getTextSize()
# Функция cv2.getTextSize() в OpenCV используется для вычисления размера текста, который будет отображаться на
# изображении. Она возвращает ширину и высоту текста в пикселях, а также позицию нижней линии текста относительно базовой
# линии. Эти значения полезны для точного размещения текста на изображении.
#
# Синтаксис
# text_size, baseline = cv2.getTextSize(text, fontFace, fontScale, thickness)

# Аргументы:
# text (строка):
# Текст, размер которого нужно вычислить.
#
# fontFace (целое число):
# Шрифт, который будет использоваться для текста.
# Доступные шрифты в OpenCV:
#
# cv2.FONT_HERSHEY_SIMPLEX: Простой шрифт без засечек.
# cv2.FONT_HERSHEY_PLAIN: Очень простой шрифт без засечек.
# cv2.FONT_HERSHEY_DUPLEX: Шрифт без засечек с двойным отображением.
# cv2.FONT_HERSHEY_COMPLEX: Более сложный шрифт с засечками (поддерживает кириллицу)
# cv2.FONT_HERSHEY_TRIPLEX: Шрифт с засечками и утроенной толщиной.
# cv2.FONT_HERSHEY_SCRIPT_SIMPLEX: Стиль рукописного шрифта.
# cv2.FONT_HERSHEY_SCRIPT_COMPLEX: Более сложный стиль рукописного шрифта.
# fontScale (вещественное число):
# Масштаб шрифта. Значение определяет относительный размер текста.
#
# thickness (целое число):
# Толщина линий, которыми рисуется текст (в пикселях).
#
# Возвращаемые значения:
# text_size (кортеж (width, height)):
# Размер текста:
#
# width: Ширина текста в пикселях.
# height: Высота текста в пикселях.
# baseline (целое число):
# Расстояние от базовой линии до нижней границы текста.

# font = cv2.FONT_HERSHEY_COMPLEX
# text_size = cv2.getTextSize(rect_label, font, 1, 2)[0] #baseline не используем
# text_x = rect_x + (rect_width - text_size[0]) // 2
# text_y = rect_y + (rect_height + text_size[1]) // 2
# cv2.putText(frame, rect_label, (text_x, text_y), font, 1, (255, 255, 255), 2)
# Такой подход позволит точно располагать текст внутри виртуальных элементов управления.

# Анимация ожидания
# В этом, и следующих шагах разработаем интерактивную систему ввода PIN-кода (с ограничением используемых цифр от 1 до 5).
#
# Начнем с создание анимации удержания:

import cv2
import numpy as np
import time

# Параметры
frame_width = 70
frame_height = 70
circle_radius = 30
circle_center = (35, 35)

# Таймер
start_time = time.time()

# Инициализация окна
cv2.namedWindow("Circle Animation")

while True:
    # Чтение кадра
    frame = np.zeros((frame_height, frame_width, 3), dtype=np.uint8)

    # Вычисление времени прошедшего с начала
    elapsed_time = time.time() - start_time
    fraction = elapsed_time / 2.0  # Прогресс анимации

    if fraction >= 1.0:
        # Сбрасываем таймер после завершения цикла
        start_time = time.time()
        fraction = 0

    # Углы для дуг
    angle = 360 * fraction

    # Рисуем первую дугу (зеленая)
    axes = (circle_radius, circle_radius)
    cv2.ellipse(frame, circle_center, axes, -90, 0, angle, (0, 255, 0), 5)

    # Рисуем вторую дугу (красная)
    cv2.ellipse(frame, circle_center, axes, -90, angle, 360, (0, 0, 255), 5)

    # Отображаем анимацию
    cv2.imshow("Circle Animation", frame)

    # Завершаем цикл по нажатию Esc
    if cv2.waitKey(10) == 27:
        break

cv2.destroyAllWindows()


# тот код создает анимацию с двумя дугами, которые рисуются на экране в рамках окна с использованием библиотеки OpenCV.
#
# Начальные параметры изображения:
# frame_width = 70
# frame_height = 70
# circle_radius = 30
# circle_center = (35, 35)
# frame_width, frame_height — размеры окна, в котором будет отображаться анимация (70x70 пикселей).
# circle_radius — радиус круга (30 пикселей).
# circle_center — центр круга (35, 35), что соответствует центру окна, так как размер окна 70x70.
# Таймер
# start_time = time.time()
# start_time сохраняет время начала работы программы, чтобы отслеживать, сколько времени прошло с начала анимации.
#  Расчет времени, прошедшего с начала
# elapsed_time = time.time() - start_time
# fraction = elapsed_time / 2.0  # Прогресс анимации (не ограничен)
# elapsed_time вычисляет время, прошедшее с момента начала работы программы.
# fraction — прогресс анимации, который изменяется от 0 до 1 за 2 секунды. Это значение не ограничено, что позволяет анимации двигаться быстрее, если пройдет больше времени
# Сброс времени
# if fraction >= 1.0:
#     start_time = time.time()
#     fraction = 0
# Когда fraction достигает или превышает 1.0, таймер сбрасывается и начинается новый цикл. Это нужно, чтобы анимация повторялась бесконечно. В реальном примере поведение анимации должно настраиваться согласно поставленным задачам!
#
# Вычисление углов для дуг, и их отображение
# angle = 360 * fraction
# # Рисуем первую дугу (зеленая)
# axes = (circle_radius, circle_radius)
# cv2.ellipse(frame, circle_center, axes, -90, 0, angle, (0, 255, 0), 5)
#
# # Рисуем вторую дугу (красная)
# cv2.ellipse(frame, circle_center, axes, -90, angle, 360, (0, 0, 255), 5)
# Вычисляет угол дуги, который зависит от прогресса анимации. Чем больше fraction, тем больший угол рисуется для дуги (от 0 до 360 градусов).
# cv2.ellipse() рисует дугу на изображении. Параметры:
# frame — изображение, на котором рисуется дуга.
# circle_center — центр дуги.
# axes — размеры осей эллипса (в данном случае радиус круга для обоих измерений).
# -90 — угол наклона эллипса на начальной позиции (сдвиг для удобного расположения дуг).
# 0, angle — начальный и конечный углы для первой дуги (зеленая).
# angle, 360 — начальный и конечный углы для второй дуги (красная).
# (0, 255, 0) и (0, 0, 255) — цвет дуг (зеленый и красный).
# 5 — толщина линии.