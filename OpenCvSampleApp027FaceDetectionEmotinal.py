# Анализ и поиск ключевых точек MediaPipe Face Mesh
# Данный инструмент формирует полную трёхмерную сетку из 468 ключевых точек, равномерно распределённых по всей поверхности
# лица. Этот набор точек можно рассматривать как высокоточную «цифровую модель» лица в реальном времени.
#
# Что нам это даёт?
#
# Определение эмоций и анализ мимики: Имея под рукой детализированную информацию о положении отдельных участков лица
# (например, уголков губ, положения век, формы бровей), можно строить сложные алгоритмы, распознающие эмоции и характерные
# мимические паттерны. Сопоставляя текущее положение контрольных точек с «эталонными» конфигурациями для определённой эмоции,
# мы можем понять, улыбается ли человек, удивлён ли он, нахмурился или смеётся.
#
# Наложение дополненной реальности (AR) и масок: Когда у нас есть точная сетка лица, мы можем проектировать на неё
# любые 2D- или 3D-объекты. С помощью перспективных преобразований (например, вычисления гомографии или матриц камеры)
# можно «приклеить» к лицу виртуальные очки, усы, шляпу или целую анимацию, которая будет реалистично следовать за
# движениями головы и мимикой гораздо точнее, чем мы это делали в предыдущем уроке.
#
# Подготовка к задачам анализа: изучение индексов ключевых точек
#
# Прежде чем перейти к распознаванию эмоций или наложению масок, нам нужно чётко понимать, какие именно ключевые
# точки отвечают за те или иные участки лица. Face Mesh нумерует точки от 0 до 467. Каждая точка имеет свои координаты,
# причем они нормализованы относительно размеров кадра (координаты x и y находятся в диапазоне от 0 до 1).


# Наша текущая задача – интерактивно просмотреть и понять, где располагаются те или иные точки. Для удобства
# поиска нужных точек воспользуйтесь скриптом, который не только отрисовывает сетку на лице, но и позволяет
# «пролистывать» индексы точек, выводя номера интересующих нас ключевых маркеров прямо на изображение.
#
# Google Сolab для решения этой задачи с фотографией. Интерактивного выделения точек тут реализовать
# не получится, в отличии от скрипта.
#
# А вот в скрипте, используйте клавиши a, d, s, w, чтобы изменять диапазон индексов и таким образом
# «прокручивать» номера точек. Например, можно шаг за шагом перемещаться по сетке, изучая, где какая точка находится.
import cv2
import mediapipe as mp
import numpy as np
import os

# Инициализация MediaPipe Face Mesh
mp_face_mesh = mp.solutions.face_mesh
face_mesh = mp_face_mesh.FaceMesh(
    static_image_mode=False,
    max_num_faces=1,
    refine_landmarks=True,
    min_detection_confidence=0.5,
    min_tracking_confidence=0.5
)

mp_drawing = mp.solutions.drawing_utils
drawing_spec = mp_drawing.DrawingSpec(thickness=1, circle_radius=1)

# Захват видео с камеры
cap = cv2.VideoCapture(0)
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)

# Инициализация диапазона индексов
start_idx = 0
end_idx = 1  # Всего 468 точек в Face Mesh

while cap.isOpened():
    success, frame = cap.read()
    if not success:
        break

    # Поворот кадра для зеркального отображения
    frame = cv2.flip(frame, 1)

    # Конвертация в RGB для MediaPipe
    frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

    # Обработка кадра
    results = face_mesh.process(frame_rgb)

    if results.multi_face_landmarks:
        for face_landmarks in results.multi_face_landmarks:

            # Рисование ключевых точек лица
            mp_drawing.draw_landmarks(
                image=frame,
                landmark_list=face_landmarks,
                connections=mp_face_mesh.FACEMESH_TESSELATION,
                landmark_drawing_spec=None,
                connection_drawing_spec=drawing_spec
            )

            # Отображение номеров точек в заданном диапазоне
            for idx, landmark in enumerate(face_landmarks.landmark):
                if start_idx <= idx <= end_idx:
                    x = int(landmark.x * frame.shape[1])
                    y = int(landmark.y * frame.shape[0])
                    # Наносим номер точки на изображение
                    cv2.circle(frame, (x,y), 5, (255,0,0), -1)
                    cv2.putText(frame, str(idx), (x, y), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 0), 2)
    else:
        cv2.putText(frame, 'Лицо не обнаружено', (30, 50), cv2.FONT_HERSHEY_COMPLEX, 1, (0, 0, 255), 2)

    # Отображение текущего диапазона
    cv2.putText(frame, f'Диапазон: {start_idx}-{end_idx}', (30, 70), cv2.FONT_HERSHEY_COMPLEX, 1, (0, 255, 0), 2)

    cv2.imshow('Face Mesh', frame)

    key = cv2.waitKey(20) & 0xFF
    if key == 27:  # ESC для выхода
        break
    elif key == ord('a'):
        start_idx = max(0, start_idx - 1)
    elif key == ord('d'):
        start_idx = min(end_idx, start_idx + 1)
    elif key == ord('s'):
        end_idx = max(start_idx, end_idx - 1)
    elif key == ord('w'):
        end_idx = min(467, end_idx + 1)

cap.release()
cv2.destroyAllWindows()

# В этом коде создается два индекса (start_idx и end_idx), чтобы иметь возможность указывать диапазон точек, которые хотим подсветить на кадре.
#
# # Отображение номеров точек в заданном диапазоне
# for idx, landmark in enumerate(face_landmarks.landmark):
#     if start_idx <= idx <= end_idx:
#         x = int(landmark.x * frame.shape[1])
#         y = int(landmark.y * frame.shape[0])
#         # Наносим номер точки на изображение
#         cv2.putText(frame, str(idx), (x, y),cv2.FONT_HERSHEY_SIMPLEX, 0.3, (0, 255, 0), 1)
# Здесь мы идём по всем точкам лица и, если индекс точки попадает в указанный диапазон, подписываем её номер на кадре.
# Обратите еще раз внимание на то, что координаты каждого landmark – это нормализованные величины от 0 до 1, поэтому
# мы умножаем их на ширину (frame.shape[1]) и высоту (frame.shape[0]) кадра, чтобы получить пиксельные координаты.
#
# Дальнейшие шаги
#
# Идентификация контрольных точек для эмоций: Определив интересующие нас зоны (уголки рта, кончик носа, контуры бровей),
# мы сможем отслеживать их движение. Наблюдая за изменением расстояний между определенными точками или за углами линий
# (например, изгиб губ), можно реализовать простые модели распознавания эмоций.
#
# Проецирование масок: Зная положение точек, соответствующих, к примеру, глазам или скулам, мы
# сможем наложить на изображение виртуальные очки или маску. Подобрав ключевые точки в качестве «якорей», будет возможно
# применить матричные преобразования, чтобы 2D-изображение или 3D-объект корректно «подстроился» под ракурс и мимику лица.
#
# Таким образом, данный скрипт является важным переходным этапом. Он не просто отрисовывает сетку,
# но и даёт нам практический инструмент для изучения индексов ключевых точек. Освоив позиционирование точек,
# вы сможете уверенно двигаться в сторону более продвинутых сценариев: от анализа мимики до реалистичных AR-масок и фильтров.