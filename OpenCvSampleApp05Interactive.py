# Добавляем интерактив
# В этом шаге мы создадим скрипт, который позволяет интерактивно устанавливать и
# удалять точки на изображении по нажатию левой и правой кнопок мыши. Для этого
# мы будем использовать функции OpenCV для обработки событий мыши.
#
# Основные моменты скрипта:
# Цикл обработки событий:
#
# Цикл while используется для постоянного обновления окна и обработки событий мыши в реальном времени.
# Это позволяет нам динамически обновлять изображение, добавляя или удаляя точки при каждом событии мыши.
# Создание копии изображения:
#
# При каждом обновлении кадра создается копия исходного изображения img_copy = img.copy().
# Это необходимо для того, чтобы можно было откатываться к исходному изображению при удалении точек, не изменяя оригинал.
# Глобальная переменная:
#
# Список для хранения координат точек используется как глобальная переменная.
# Это позволяет функции обработки событий мыши изменять его значение, сохраняя состояние между вызовами функции.
# Ключевое слово global используется внутри функции для указания, что переменная является глобальной. Это необходимо,
# чтобы функция могла изменять значение переменной, объявленной вне ее тела.

# import cv2
# import numpy as np
#
# # Глобальная переменная для хранения координат точек
# points = []
#
#
# def mouse_callback(event, x, y, flags, param):
#     global points
#     if event == cv2.EVENT_LBUTTONDOWN:
#         # Добавление точки при нажатии левой кнопки мыши
#         points.append((x, y))
#         print(f"Точка добавлена в ({x}, {y})")
#     elif event == cv2.EVENT_RBUTTONDOWN:
#         # Удаление точки при нажатии правой кнопки мыши
#         if points:
#             removed_point = points.pop()
#             print(f"Удалена точка {removed_point}")
#
#
# # Загрузка изображения
# img = np.zeros((500, 500, 3), np.uint8)
# cv2.imshow('image', img)
#
# # Установка функции обратного вызова
# cv2.setMouseCallback('image', mouse_callback)
#
# while True:
#     # Создание копии изображения для обновления
#     img_copy = img.copy()
#
#     # Рисование всех точек на изображении
#     for point in points:
#         cv2.circle(img_copy, point, 10, (0, 0, 255), -1)
#
#     # Отображение изображения с точками
#     cv2.imshow('image', img_copy)
#
#     # Выход из цикла при нажатии клавиши 'Esc'
#     if cv2.waitKey(20) == 27:
#         break
#
# cv2.destroyAllWindows()


# Рисуем прямоугольник по двум точкам
# В этом шаге мы создадим скрипт, который позволяет рисовать прямоугольник по двум точкам на изображении.
#
# После первого клика мыши устанавливается первая точка,
# После второго клика рисуется прямоугольник,
# После третьего клика все точки удаляются.
#
# Во время второго этапа (когда нарисован прямоугольник) по нажатию кнопки пробел
# ( код 32 ) сохраняется обрезанное изображение в переменную cropped_image.png.

# import cv2
# import numpy as np
#
# # Глобальные переменные для хранения координат точек и обрезанного изображения
# points = []
# cropped_image = None
#
#
# def mouse_callback(event, x, y, flags, param):
#     global points
#     if event == cv2.EVENT_LBUTTONDOWN:
#         if len(points) < 2:
#             # Добавление точки при первом и втором клике
#             points.append((x, y))
#             print(f"Точка добавлена в ({x}, {y})")
#         else:
#             # Удаление точек при третьем клике
#             points.clear()
#             print("Точки удалены")
#
#
# # Загрузка изображения
# img = cv2.imread("input_image.jpg")
# cv2.imshow('image', img)
#
# # Установка функции обратного вызова
# cv2.setMouseCallback('image', mouse_callback)
#
# while True:
#     # Создание копии изображения для обновления
#     img_copy = img.copy()
#
#     if len(points) == 1:
#         # Рисование первой точки
#         cv2.circle(img_copy, points[0], 5, (0, 0, 255), -1)
#     elif len(points) == 2:
#         # Рисование прямоугольника по двум точкам
#         cv2.rectangle(img_copy, points[0], points[1], (0, 255, 0), 2)
#
#     # Отображение изображения с точками и/или прямоугольником
#     cv2.imshow('image', img_copy)
#
#     key = cv2.waitKey(20)
#     if key == 27:  # Выход из цикла при нажатии клавиши 'Esc'
#         break
#     elif key == 32:  # Сохранение обрезанного изображения при нажатии пробела
#         if len(points) == 2:
#             x1, y1 = points[0]
#             x2, y2 = points[1]
#             x_min, x_max = min(x1, x2), max(x1, x2)
#             y_min, y_max = min(y1, y2), max(y1, y2)
#             cropped_image = img[y_min:y_max, x_min:x_max]
#             cv2.imwrite("cropped_image.png", cropped_image)
#             print("Изображение обрезано и сохранено")
#
# cv2.destroyAllWindows()

# Этот скрипт позволяет интерактивно рисовать прямоугольник на изображении с использованием мыши и
# сохранять обрезанное изображение по нажатию пробела. Вот как он работает:
# 1. Подготовка:
# Глобальные переменные: Объявляются две глобальные переменные:
# points для хранения координат точек (начальная и конечная точки прямоугольника).
# cropped_image для хранения обрезанного изображения.
# 2. Функция обработки событий мыши (mouse_callback):
# Назначение: Функция вызывается при каждом событии мыши в окне.
# Параметры: Функция принимает параметры события (event), координаты (x, y), флаги (flags) и
# дополнительные параметры (param).
# Обработка событий:
# Первый клик (левая кнопка мыши):
# Если список points содержит меньше двух точек, текущие координаты (x, y) добавляются в список.
# Печатается сообщение с координатами добавленной точки.
# Второй клик:
# Если список points содержит одну точку, текущие координаты (x, y) добавляются в список.
# Рисуется прямоугольник
# Третий клик (левая кнопка мыши):
# Если список points уже содержит две точки, при третьем клике все точки удаляются из списка.
# Печатается сообщение о том, что точки удалены.
# 3. Загрузка и отображение изображения:
# Создание изображения: загружается изображение из файла
# Отображение изображения: Изображение отображается в окне с именем 'image'.
# 4. Установка функции callback:
# Привязка функции: Функция cv2.setMouseCallback связывает окно 'image' с функцией mouse_callback,
# чтобы обрабатывать события мыши в этом окне.
# 5. Основной цикл:
# Цикл while: Этот цикл выполняется бесконечно до тех пор, пока не будет нажата клавиша 'Esc'.
# Создание копии изображения: При каждом обновлении создается копия исходного изображения (img_copy = img.copy()).
# Это нужно для того, чтобы изменения не затрагивали оригинал.
# Рисование объектов:
# Если одна точка: Если в списке points есть одна точка, на изображении рисуется круг на этой точке.
# Если две точки: Если в списке points есть две точки, на изображении рисуется прямоугольник, определенный этими точками.
# Отображение изображения: Обновленное изображение отображается в окне.
# Обработка нажатий клавиш:
# Выход из цикла (клавиша 'Esc'): Если нажата клавиша 'Esc', цикл прерывается и программа завершает работу.
# Сохранение обрезанного изображения (пробел):
# Если нажата клавиша пробел и в списке points есть две точки, рассчитываются координаты верхнего левого и
# нижнего правого углов прямоугольника.
# Обрезанное изображение сохраняется в переменную cropped_image.
# Печатается сообщение о сохранении обрезанного изображения.
# 6. Завершение программы:
# Закрытие окон: После завершения работы цикла все окна OpenCV закрываются с помощью cv2.destroyAllWindows().


# Рисуем прямоугольник интерактивно
# В этом шаге мы создадим скрипт, который позволяет интерактивно рисовать прямоугольник на изображении,
# обрабатывая нажатие и перемещение мыши.
# Прямоугольник будет обновляться в реальном времени по мере движения, при удержании левой кнопки мыши.
# import cv2
# import numpy as np
#
# # Глобальные переменные для хранения начальной и конечной точек прямоугольника
# start_point = None
# end_point = None
# drawing = False
# cursor_position = (0, 0)
#
#
# def mouse_callback(event, x, y, flags, param):
#     global start_point, end_point, drawing, cursor_position
#     cursor_position = (x, y)
#     if event == cv2.EVENT_LBUTTONDOWN:
#         # Начало рисования прямоугольника
#         start_point = (x, y)
#         drawing = True
#     elif event == cv2.EVENT_MOUSEMOVE and drawing:
#         # Обновление конечной точки при движении мыши
#         end_point = (x, y)
#     elif event == cv2.EVENT_LBUTTONUP:
#         # Завершение рисования прямоугольника
#         end_point = (x, y)
#         drawing = False
#     elif event == cv2.EVENT_RBUTTONDOWN:
#         # Удаление прямоугольника по нажатию правой кнопки мыши
#         start_point = None
#         end_point = None
#
#
# # Загрузка изображения
# img = cv2.imread('input_image.jpg')
# img_original = img.copy()  # Сохраняем оригинал изображения для обрезки
# cv2.imshow('image', img)
#
# # Установка функции обратного вызова
# cv2.setMouseCallback('image', mouse_callback)
#
# while True:
#     # Создание копии изображения для обновления
#     img_copy = img.copy()
#
#     # Вывод координат курсора на изображение
#     cursor_text = f"Положение курсора: {cursor_position}"
#     cv2.putText(img_copy, cursor_text, (10, 30), cv2.FONT_HERSHEY_COMPLEX, 0.9, (255, 255, 255), 2, cv2.LINE_AA)
#
#     if start_point and end_point:
#         # Рисование прямоугольника по начальной и конечной точкам
#         cv2.rectangle(img_copy, start_point, end_point, (0, 255, 0), 2)
#         # Вывод координат на изображение
#         rect_text = f"Точка 1: {start_point}, Точка 2: {end_point}"
#         cv2.putText(img_copy, rect_text, (10, 60), cv2.FONT_HERSHEY_COMPLEX, 0.9, (0, 255, 0), 2, cv2.LINE_AA)
#
#     elif start_point:
#         # Вывод координат начальной точки на изображение
#         start_text = f"Точка 1: {start_point}"
#         cv2.putText(img_copy, start_text, (10, 60), cv2.FONT_HERSHEY_COMPLEX, 0.9, (0, 255, 0), 2, cv2.LINE_AA)
#
#     # Отображение изображения с прямоугольником и текстом
#     cv2.imshow('image', img_copy)
#
#     key = cv2.waitKey(20)
#     if key == 27:  # Выход из цикла при нажатии клавиши 'Esc'
#         break
#     elif key == 32:  # Сохранение обрезанного изображения при нажатии пробела
#         if start_point and end_point:
#             x1, y1 = start_point
#             x2, y2 = end_point
#             x_min, x_max = min(x1, x2), max(x1, x2)
#             y_min, y_max = min(y1, y2), max(y1, y2)
#             cropped_image = img_original[y_min:y_max, x_min:x_max]
#             cv2.imwrite('cropped_image.jpg', cropped_image)
#             print("Обрезанное изображение сохранено как 'cropped_image.jpg'")
#
# cv2.destroyAllWindows()

# Пояснения к коду:
# Загрузка изображения:
#
# Чтение изображения: img = cv2.imread('input_image2.jpg') загружает изображение из файла input_image2.jpg.
# Сохранение оригинала: img_original = img.copy() сохраняет оригинальное изображение для последующей обрезки.
# Обработка событий мыши:
#
# Обновление координат курсора: cursor_position = (x, y) обновляет глобальную переменную cursor_position
# с текущими координатами курсора.
# Начало рисования (EVENT_LBUTTONDOWN): Устанавливается начальная точка прямоугольника и включается флаг drawing.
# Обновление конечной точки (EVENT_MOUSEMOVE): При движении мыши и активном флаге drawing обновляется конечная точка
# прямоугольника.
# Завершение рисования (EVENT_LBUTTONUP): Устанавливается конечная точка прямоугольника и отключается флаг drawing.
# Удаление прямоугольника (EVENT_RBUTTONDOWN): Устанавливает start_point и end_point в None, что приводит к удалению
# прямоугольника.
# Обновление изображения:
#
# Цикл while: Цикл постоянно обновляет окно и отображает изменения в реальном времени.
# Создание копии изображения: img_copy = img.copy() создается копия загруженного изображения для отката к оригиналу
# при изменении прямоугольника.
# Вывод текста на изображение:
# Координаты курсора выводятся в верхнем левом углу белым цветом.
# Информация о прямоугольнике выводится зеленым цветом.
# Сохранение обрезанного изображения:
#
# По нажатию пробела: Если нарисован прямоугольник, рассчитываются координаты верхнего левого и нижнего правого углов
# прямоугольника.
# Обрезка изображения: Обрезанное изображение сохраняется из оригинала img_original без границ прямоугольника и
# наложенного текста.
# Сохранение файла: cv2.imwrite('cropped_image.png', cropped_image) сохраняет обрезанное изображение в
# файл cropped_image.png.

# СуперМегаКомбо
# И теперь, в завершении методов, позволяющих вырезать прямоугольные области на изображениях -  супер-скрипт, который
# значительно облегчит вашу работу с изображениями в дальнейшем! Этот скрипт обладает следующими возможностями:
#
# Множественный выбор: Вы можете выделить любое количество прямоугольников на изображении, просто щелкнув и перетаскивая мышь.
# Удаление прямоугольников: Нажмите правую кнопку мыши, чтобы удалить все выделенные прямоугольники и начать заново.
# Сохранение обрезанных изображений: По нажатию пробела все выделенные области будут обрезаны и сохранены в отдельные
# файлы с уникальными именами в формате originalFilename_crop001.png, originalFilename_crop002.png и так далее.
# Этот инструмент будет очень полезен для задачи разметки данных, когда необходимо выделить и сохранить определенные
# области изображения для дальнейшего анализа или обучения моделей нейросетей.

import cv2
import numpy as np
import os

# Глобальные переменные для хранения координат прямоугольников и состояния рисования
rectangles = []
drawing = False
current_rect = None
cursor_position = (0, 0)


def mouse_callback(event, x, y, flags, param):
    global current_rect, drawing, cursor_position
    cursor_position = (x, y)
    if event == cv2.EVENT_LBUTTONDOWN:
        # Начало рисования нового прямоугольника
        current_rect = [(x, y)]
        drawing = True
    elif event == cv2.EVENT_MOUSEMOVE and drawing:
        # Обновление конечной точки текущего прямоугольника при движении мыши
        if current_rect:
            if len(current_rect) == 1:
                current_rect.append((x, y))
            else:
                current_rect[1] = (x, y)
    elif event == cv2.EVENT_LBUTTONUP:
        # Завершение рисования текущего прямоугольника
        if current_rect:
            current_rect.append((x, y))
            rectangles.append(tuple(current_rect))
            current_rect = None
            drawing = False
    elif event == cv2.EVENT_RBUTTONDOWN:
        # Удаление всех прямоугольников по нажатию правой кнопки мыши
        rectangles.clear()


# Загрузка изображения
image_path = 'input_image.jpg'
img = cv2.imread(image_path)
img_original = img.copy()  # Сохраняем оригинал изображения для обрезки
cv2.imshow('image', img)

# Установка функции обратного вызова
cv2.setMouseCallback('image', mouse_callback)

while True:
    # Создание копии изображения для обновления
    img_copy = img.copy()

    # Вывод координат курсора на изображение
    cursor_text = f"Положение курсора: {cursor_position}"
    cv2.putText(img_copy, cursor_text, (10, 30), cv2.FONT_HERSHEY_COMPLEX, 0.9, (255, 255, 255), 2, cv2.LINE_AA)

    # Рисование всех прямоугольников
    for rect in rectangles:
        cv2.rectangle(img_copy, rect[0], rect[1], (0, 255, 0), 2)
        rect_text = f"Точка 1: {rect[0]}, Точка 2: {rect[1]}"
        cv2.putText(img_copy, rect_text, (rect[0][0], rect[0][1] - 10), cv2.FONT_HERSHEY_COMPLEX, 0.5, (0, 255, 0), 1,
                    cv2.LINE_AA)

    # Рисование текущего прямоугольника
    if current_rect and len(current_rect) == 2:
        cv2.rectangle(img_copy, current_rect[0], current_rect[1], (0, 255, 0), 2)
        rect_text = f"Точка 1: {current_rect[0]}, Точка 2: {current_rect[1]}"
        cv2.putText(img_copy, rect_text, (current_rect[0][0], current_rect[0][1] - 10), cv2.FONT_HERSHEY_COMPLEX, 0.5,
                    (0, 255, 0), 1, cv2.LINE_AA)

    # Отображение изображения с прямоугольниками и текстом
    cv2.imshow('image', img_copy)

    key = cv2.waitKey(20)
    if key == 27:  # Выход из цикла при нажатии клавиши 'Esc'
        break
    elif key == 32:  # Сохранение всех обрезанных изображений при нажатии пробела
        base_name = os.path.splitext(os.path.basename(image_path))[0]
        for i, rect in enumerate(rectangles):
            x1, y1 = rect[0]
            x2, y2 = rect[1]
            x_min, x_max = min(x1, x2), max(x1, x2)
            y_min, y_max = min(y1, y2), max(y1, y2)
            cropped_image = img_original[y_min:y_max, x_min:x_max]
            save_name = f"{base_name}_crop{i + 1:03d}.png"
            cv2.imwrite(save_name, cropped_image)
            print(f"Обрезанное изображение сохранено как '{save_name}'")

cv2.destroyAllWindows()