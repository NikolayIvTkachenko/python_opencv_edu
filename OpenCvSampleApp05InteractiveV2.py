# Поиск шаблона и вставка вырезанных изображений
# Когда у нас есть множество вырезанных изображений, попробуем вставить их обратно в оригинальное изображение.
# Звучит, как "эффективный труд", сначала нарезать на куски, а потом собирать обратно, но тем не
# менее, при поиске объектов этот метод может быть очень полезен!

# Функция cv2.matchTemplate
# Функция cv2.matchTemplate в OpenCV используется для выполнения задачи поиска шаблона. Эта функция принимает
# изображение и шаблон и возвращает карту корреляции, которая показывает, насколько хорошо каждый участок изображения
# соответствует шаблону.
#
# result = cv2.matchTemplate(image, templ, method)
# Параметры
# image : Входное изображение, в котором нужно найти шаблон. Может быть как цветным, так и черно-белым.
#
# templ : Шаблон для поиска. Размеры должны быть меньше, чем у изображения.
#
# method (int): Метод, используемый для сопоставления. Доступны следующие методы:
#
# cv2.TM_SQDIFF: Метод квадратичного отклонения. Возвращает местоположение с минимальным значением для наилучшего совпадения.
# cv2.TM_SQDIFF_NORMED: Нормализованный метод квадратичного отклонения. Похож на TM_SQDIFF, но значения нормализованы.
# cv2.TM_CCORR: Метод кросс-корреляции. Возвращает местоположение с максимальным значением для наилучшего совпадения.
# cv2.TM_CCORR_NORMED: Нормализованный метод кросс-корреляции. Похож на TM_CCORR, но значения нормализованы.
# cv2.TM_CCOEFF: Метод коэффициента корреляции. Возвращает местоположение с максимальным значением для наилучшего совпадения.
# cv2.TM_CCOEFF_NORMED: Нормализованный метод коэффициента корреляции. Похож на TM_CCOEFF, но значения нормализованы.
# Возвращаемое значение
# result : Карту корреляции, где каждый элемент показывает, насколько хорошо соответствующая область изображения
# совпадает с шаблоном. Размер карты корреляции:
# (W - w + 1, H - h + 1), где W и H — ширина и высота изображения, а w и h — ширина и высота шаблона.

# После того как мы получили карту корреляции result с помощью функции cv2.matchTemplate, нам нужно определить,
# где на изображении находится наилучшее совпадение с шаблоном. Для этого мы используем функцию cv2.minMaxLoc.
#
# Функция cv2.minMaxLoc находит минимальные и максимальные значения в массиве (в данном случае в карте корреляции) и их позиции.
#
# min_val: Минимальное значение корреляции в карте. В случае использования метода cv2.TM_SQDIFF это значение указывает
# на наилучшее совпадение.
# max_val: Максимальное значение корреляции в карте. В случае использования методов cv2.TM_CCORR, cv2.TM_CCOEFF и
# их нормализованных версий это значение указывает на наилучшее совпадение.
# В зависимости от метода, который вы выбрали для cv2.matchTemplate, наилучшее совпадение будет либо в min_loc, либо в max_loc.
#
# min_loc: Координаты (x, y) минимального значения корреляции в карте.
#
# max_loc: Координаты (x, y) максимального значения корреляции в карте.
# В данном примере используется метод cv2.TM_CCOEFF_NORMED, который возвращает наилучшее совпадение в max_loc.
#
# start_x, start_y = max_loc
#
# max_loc: Координаты верхнего левого угла области изображения, где шаблон максимально совпадает с изображением.
# start_x, start_y: Эти переменные содержат координаты верхнего левого угла наилучшего совпадения.

import cv2
import numpy as np
import base64
import matplotlib.pyplot as plt


def read_image(base64_str):
    img_data = base64.b64decode(base64_str)
    img = cv2.imdecode(np.frombuffer(img_data, np.uint8), cv2.IMREAD_COLOR)
    return img


def find_template(original, template):
    result = cv2.matchTemplate(original, template, cv2.TM_CCOEFF_NORMED)

    # Переворот карты результата по оси Y, для правильной визуализации
    result_flipped = np.flipud(result)

    # Сохранение визуализации result в PNG файл
    plt.figure(figsize=(10, 5))
    plt.imshow(result_flipped, cmap='hot')
    plt.colorbar()
    plt.title('Карта совпадений')
    plt.savefig('template_matching_result.png')
    plt.close()

    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)
    start_x, start_y = max_loc
    end_x = start_x + template.shape[1]
    end_y = start_y + template.shape[0]
    return (start_x, start_y, end_x, end_y)


original_img = cv2.imread("full.png")
template_img = cv2.imread("part.png")

# Поиск координат шаблона на оригинальном изображении
coords = find_template(original_img, template_img)
print(coords)